##
# \file trajectory.py
# \author Michael P. Howard
# \author Andrew P. Santos
# \date 6 Jaunary 2015
# \brief Implementation of Python wrappers to the Trajectory Objects

import libmdalyzer

##
# \package mdalyzer.trajectory
# \brief Defines Python wrappers to the Trajectory Objects
#
# Trajectories hold data on molecular simulations; this data is then analyzed by analyzers. Data includes positions, velocities, particle type/name, masses and diameters.

## \internal
# \brief Abstract definition of a Trajectory
# 
class trajectory(object):
    ## \internal
    # \brief initializes a trajectory
    #
    """Base class for Trajectory"""
    def __init__(self):
        self.cpp = None
    
    ## \internal
    # \brief Reads the trajectory and runs the analysis (only if analyzers are attached)
    #
    # \b Examples:
    # \code
    # #  Two pdb files separated by 2.0 ts
    # t = trajectory.pdb( files=['frame1.pdb','frame2.pdb'], time_step=2.0)
    #
    # # add analyzers, see analyzer.py documentation
    # # analyze
    # t.analyze()
    # \endcode
    #
    def analyze(self):
        """Perform Trajectory analysis"""
        self.cpp.analyze()

    ## \var analyze
    # \internal
    # \brief Python object that performs Trajectory analysis
    # \sa trajectory.analyze
        
    ## \internal
    # \brief Add file(s) to the trajectory
    # \param files Trajectory file(s) 
    #
    # \b Examples:
    # \code
    # #  initialize a PDB trajectory
    # t = trajectory.pdb()
    #
    # # add files
    # t.add(['frame1.pdb','frame2.pdb','frame3.pdb'])
    # \endcode
    #
    def add(self, files):
        """Attach files"""
        if not isinstance(files, (list,tuple)):
            files = [files]
        
        for file in files:
            self.cpp.addFile(file)   

    ## \var addFile
    # \internal
    # \brief C++ Function that adds file to trajectory
            
    ## \internal
    # \brief Define the Triclinic Box dimensions
    # \param lx Length of the box in the x-direction
    # \param ly Length of the boy in the y-direction
    # \param lz Length of the boz in the z-direction
    # \param xy Tilt of the x-y angle
    # \param xz Tilt of the x-z angle
    # \param yz Tilt of the y-z angle
    #
    # \b Examples:
    # \code
    # #  initialize a PDB trajectory
    # t = trajectory.pdb()
    #
    # # add files
    # t.add(['frame1.pdb','frame2.pdb','frame3.pdb'])
    #
    # # set an othrombic box of equal size
    # t.set_box( lx=10.0, ly=10.0, lz=10.0)
    #
    # # set an 2D rectangular box
    # t.set_box( lx=10.0, ly=10.0)
    #
    # # set an Box with a tilt
    # t.set_box( lx=10.0, ly=10.0, lz=5.0, xy=0.5, yz=0.2)
    # \endcode
    #
    def set_box(self, lx=0.0, ly=0.0, lz=0.0, xy=0.0, xz=0.0, yz=0.0):
        if self.cpp is None:
            raise RuntimeError('Box cannot be set without constructing a Trajectory')
        self.box = libmdalyzer.TriclinicBox(libmdalyzer.Vector3d(lx,ly,lz), libmdalyzer.Vector3d(xy,xz,yz))
        self.cpp.setBox(self.box)
#     def set_box(v1, v2, v3):
#         if len(v1) != 3 or len(v2) != 3 or len(v3) != 3:
#             raise RuntimeError('Box is defined by three 3d vectors')
#         
#         self.box = libmdalyzer.TriclinicBox(libmdalyzer.Vector3d(v1[0], v1[1], v1[2]),
#                                             libmdalyzer.Vector3d(v2[0], v2[1], v2[2]),
#                                             libmdalyzer.Vector3d(v3[0], v3[1], v3[2]))
#         self.cpp.setBox(self.box)
        

## Wraps to a HOOMDXML file trajectory
#  
#  Genereally generated by the HOOMD-blue MD package
#  
class hoomd(trajectory):
    """HOOMD XML trajectory"""
    ## \internal
    # \brief Initialize hoomd trajectory
    # \param dt trajectory timestep, defalts to 1.0
    #
    # \b Examples:
    # \code
    #
    # #  generate a hoomd trajectory, with a 1.0 timestep
    # t = trajectory.hoomd()
    #
    # #  generate a hoomd trajectory, with a 0.001 timestep
    # t = trajectory.hoomd(dt=0.001)
    # t.add('frame.xml')
    # \endcode
    #
    def __init__(self, dt=1.0):
        if dt <= 0.0:
            raise RuntimeError("HOOMDXMLTrajectory timestep must be positive")
        self.cpp = libmdalyzer.HOOMDXMLTrajectory(dt)

## Wraps to a GRO file trajectory
# 
#  Genereally generated by the GROMACS MD package
#  
class gro(trajectory):
    """GRO file trajectory"""
    ## \internal
    # \brief Initialize hoomd trajectory
    # \param files trajectory files, defalts to None
    # \param precision Precision of the data, defalts to 3
    #
    # \b Examples:
    # \code
    #
    # #  generate a gro trajectory, with default precision=3, add files with add
    # t = trajectory.gro()
    # t.add(['frame2.gro'], ['frame200.gro'])
    #
    # #  generate a gro trajectory, with files and double precision
    # gro_files = ['frame0.gro','frame5.gro','frame10.gro','frame15.gro','frame20.gro']
    # t = trajectory.gro(files=gro_files, precision=8)
    # \endcode
    #
    def __init__(self,files=None,precision=3):
        self.cpp = libmdalyzer.GROTrajectory(precision)
        
        if files is not None:
            self.add(files)
            
## Wraps to a XYZ file trajectory
# 
#  Genereally generated by the LAMMPS MD package
#  
class xyz(trajectory):
    """XYZ file trajectory"""
    ## \internal
    # \brief Initialize xyz trajectory
    # \param files trajectory files, defalts to None
    #
    # \b Examples:
    # \code
    #
    # #  generate a xyz trajectory
    # t = trajectory.xyz()
    # \endcode
    #
    def __init__(self, files=None):
        self.cpp = libmdalyzer.XYZTrajectory()
            
        if files is not None:
            self.add(files)

## Wraps to a PDB file trajectory
# 
#  Genereally generated from MD simulations of proteins
#  
class pdb(trajectory):
    """PDB file trajectory"""
    ## \internal
    # \brief Initialize pdb trajectory
    # \param time_step trajectory timestep, defalts to 1.0
    # \param files trajectory files, defalts to None
    #
    # \b Examples:
    # \code
    # #  Two pdb files separated by 2.0 ts
    # t = trajectory.pdb( files=['frame1.pdb','frame2.pdb'], time_step=2.0)
    #
    # #  generate a pdb, with default time_step=1.0, add files with add
    # t = trajectory.pdb()
    # \endcode
    #
    def __init__(self, files=None, time_step=1.0):
        self.cpp = libmdalyzer.PDBTrajectory(time_step)

        if files is not None:
            self.add(files)
            
## Wraps to a DCD file trajectory
# 
#  Binary file with multiple timestep configurations
#  
class dcd(trajectory):
    """DCD trajectory object
       Make sure that all other trajectory classes preceed the dcd class, 
       as it depends on all others
    """
    ## \internal
    # \brief Initialize dcd trajectory
    # \param dcd_file trajectory file
    # \param i_file initial trajectory/Frame file name needed for DCD
    # \param i_type initial trajectory/Frame file type, defalts to None, and tries to find from the file name extensions
    # \param precision Precision of the data needed if it is a GRO file, defalts to 3
    # \param time_step trajectory timestep, defalts to 0 and will be determined by the DCD reader
    # \param freq Number of timesteps between each DCD configuration, defalts to 0 and will be determined by the DCD reader
    #
    # \b Examples:
    # \code
    # # use the DCD file's output frequency and time step, with an xml initial frame
    # t = trajectory.dcd( dcd_file='frames.dcd', i_file='frame1.xml')
    #
    # # use a GRO initial configuration with 4 Precision
    # t = trajectory.dcd( dcd_file='frames.dcd', i_file='frame1.gro', precision=4)
    #
    # # Define the output frequency output every 1000 timesteps, with a 0.001 (unit) timestep
    # t = trajectory.dcd( dcd_file='frames.dcd', i_file='frame1.xyz', time_step=0.001, freq=1000)
    #
    # # Define the ininitail file type
    # t = trajectory.dcd( dcd_file='frames.dcd', i_file='frame1.pdb', i_type='pdb')
    # \endcode
    #
    def __init__(self, dcd_file, i_file, i_type=None, precision=3, time_step=0, freq=0):
        self.dcd_file = dcd_file
        self.i_file = i_file
        self.i_file_ptr = None
        self.traj_types = ['HOOMDXML','XML', 'xml',
                           'GRO', 'gro',
                           'PDB', 'pdb',
                           'XYZ', 'xyz']
        if (i_type == None):
            i_type = self._parseFileName()
        self.i_type = i_type
        # create pointer to that trajectory
        self.i_file_ptr = self._getTraj(i_type, time_step, precision)
        # add the file frame to that pointer
        self.i_file_ptr.addFile(i_file)

        self.cpp = libmdalyzer.DCDTrajectory(self.i_file_ptr, self.dcd_file, time_step, freq)
    ## \var trajectory.dcd.i_file_ptr
    # \internal
    # \brief boost shared_ptr to a trajectory object of the initial trajectory
    #  Needed for the DCDTrajectory constructor
            

    ## \internal
    # \brief Raises an error the initial file type is incorrect
    #
    def _notAtype(self):
        err_str = ('The file type \'%s\' does not exist. Maybe you meant one of these:\n' % self.i_type)
        for t_type in self.traj_types:
            err_str += (t_type + " ")
        raise RuntimeError(err_str)

    ## \internal
    # \brief Parses the initial file name to get the file type
    #
    def _parseFileName(self):
        extension = self.i_file.split('.')
        for t_type in self.traj_types:
            if ( t_type in extension ):
                return t_type
        self._notAtype
        return None

    ## \internal
    # \brief Parses the initial file name to get the file type
    # \param t_type initial trajectory/Frame file type
    # \param time_step trajectory timestep, for the initial trajectory pointer initialization
    # \param precision Data precision, for the initial trajectory pointer initialization
    #
    def _getTraj(self, t_type, time_step, precision):
        if ( t_type in ['HOOMDXML', 'XML', 'xml'] ):
            return libmdalyzer.HOOMDXMLTrajectory(time_step)

        elif ( t_type in ['GRO', 'gro'] ):
            return libmdalyzer.GROTrajectory(precision)

        elif ( t_type in ['PDB', 'pdb'] ):
            return libmdalyzer.PDBTrajectory(time_step)

        elif ( t_type in ['XYZ', 'xyz'] ):
            return libmdalyzer.XYZTrajectory()
        
        else :
            self._notAtype()

